# 7월 3일

## 자바 스크립트 문법2
## Static
### 자바로 클래스 만들기
- (자바로 함수를 만들게 되면 stack 영역과 heap 영역에 데이터공간을 잡는다.)
- 클래스를 만든다
- 메인함수 영역에 데이터 영역을 잡아주고 변수를 만든다
- 변수에 데이터를 집에넣기 위해 : 보조 클래스를 만들어 원 클래스에서 사용할 함수를 정의해준다.
- 보조클래스에서 정의된 함수는 : heap 영역에서 데이터영역을 잡고 테이블을 만들어 데이터를 저장한다.
- 원 클래스의 메인함수영역에 생성된 변수는stack영역에 생성되고, 이 변수는 heap영역의 저장된 데이터를 가리키는 역할을 한다.
#### 공통변수 만들기
- 여러 데이터를 저장할때 공통으로 사용되는 변수가 있다면?
- 예시) 학생들의 성적 데이터를 입력할때 입력한 학생 수를 셀려면?
- 매번 카운트라는 변수를 만들어 숫자를 1,2,3,4,... 이런식으로 수동으로 입력 해 주는 방법이 있다.
- 하지만 이 방법은 너무 번거롭고, 나중에 학생수를 확인하기 위해서는 가장 마지막에 입력한 학생을 찾아야 올바른 수가 나온다는것이 문제.
- 카운트라는 변수는 매 변수에 포함되는 공통변수이므로 이걸 보조클래스에 정의하면 된다.
- 객체가 있는 곳은 heap 영역. 객체가 없으면 아무것도 할 수 없다.
- 이렇게 하면 heap영역에 있는 각각의 count 변수들이 Data영역에 만들어진 count라는 공통함수를 가리켜 사용할 수 있게 된다.
- 보조클래스에서 카운트라는 변수 앞에 데이터형식 지정하는것을 추가
    ```
    -----------------
    (원) 공통변수 지정 전 변수
    int count;

    (수정) 공통변수 지정 후 변수
    static int count = 0;
    -----------------
    ```
- 이런식으로 앞에 데이터형식을 static으로 지정해주고 0부터 시작하겠다는 정의를 한다.

- 다시 원클래스로 돌아가 count로 지정되어있는 변수를 전부 바꿔준다
    ```
    -------------------------
    (원) 공통변수 지정 전 코드
    StaticVar sv2 = new StaticVar();
    sv2.count = 2;

    StaticVar sv3 = new StaticVar();
    sv3.count = 3;

    (수정) 공통변수 지정 후 코드
    StaticVar sv1 = new StaticVar();
    //StaticVar.count = StaticVar.count+1; 또는
    StaticVar.count++;


    // 공통변수를 활용해 프린트하기
    System.out.println("지금까지 학생수는" + StaticVar.count);
    -----------------------
    ```


## Overload
- 쌓다, 적제하다.
### 11Overloading 오버로딩
- 두개의 숫자를 주면 그 두개를 더해서 우리에게 결과를 돌려주는 클래스만들기
- 원 클래스 : AddTest     - 보조 클래스를 활용하는 클래스
- 보조클래스 : Add

#### 메소드 오버로딩
- 두 수를 더한 결과를 리턴해주는 함수를 만들고싶다.
- 파이썬에서는 함수 정의를 하나만 해도 알아서 정수+실수 계산을 해 주었다.
- 하지만 자바에서는 수의 타입을 정확하게 구분하기떄문에 함수를 여러개 만들어주어야 함.
- 1번: "정수 + 정수", 2번: "정수 + 실수", 3번: "실수 + 실수" 계산을 해 주는 함수가 모두 필요.
- 하지만 이 함수의 이름을 매번 다르게 정의하면 사용할때 해당 함수 이름을 정확하게 불러와야 해서 불편하다
- 그래서 자바에서는 1,2,3번 함수 이름을 같게 써도 알아서 해당 함수를 적용해주는 기능이 있다.
- 따라서 다음과 같은 함수 작성이 가능하다
    ```
    -----------------------
        // 1. 정수 더하기
        int add(int a, int b)
            { 
            int result = a + b;
            return result; 
            }

        // 2. 실수 더하기
        double add(double a, double b)
            {double result = a + b;
            return result;}
        
        // 3. 정수와 실수 더하기
        double add(int a, double b)
            {double result = a + b;
            return result;}

        // 파라미터가 여러개여도 상관없다.
        int add(int a, int b, int c) {return a+b+c;}
    -------------------
    ```
- 숫자끼리의 더하기 연산도 되지만 문자열도 가능하다
    ```
    ----------------
        String add(String a, String b)
            {String result = a + " " + b ;
            return result;}
    ---------------------
    ```
- 이렇게 정의한 뒤, 더하는 연산을 하고싶다면 그냥 '클래스객체.함수' 형태로 호출만 하면 된다.
    ```
    -------------------
            a.add(2, 3);
            a.add(2.3, 3.541);
            a.add(3, 1.56);
            a.add(3, 1.56);
            a.add("hello", "bye");
            System.out.println( a.add("hello", "bye") );
    --------------------
    ```


## Constructor
- 메모리 공간 확보 + 데이터 저장을 한번에 하는 방법
- Member m3 = new Member("철수", "010-3333-3333","인천시 남동구");
- 이렇게 바로 파라미터에 데이터를 넣어서 한줄로 쓸 순 없을까?

### 생성자
- Member() --> 이걸 생성자라고 부름.
- new 옆에 클래스로 되어있는 애 = 생성자
- 지금까지는 생성자에 파라미터 안넣고 만들었음
- 하지만 메모리 공간확보 + 데이터 저장을 한꺼번에 처리하기 위해
- 생성자의 파라미터에 데이터를 넣을것임.
1. 
   - 여태까지 우리가 했던 생성자에는 파라미터를 안 넣었었음.
   - 눈에 안보이지만 기본적으로 Member() 의 생성자는
   - 이미 만들어져있다.
   - 그래서 에러없이 함수가 동작했던것
	
2. 
    - 이제는 파라미터가 있는 생성자가 필요함.
    - 이건 기본적으로 제공하는 것이 아니므로, 만들어줘야 한다.
    - @@ 단, 생성자는 리턴타입이 없다!!!!! ---->>>> 중요!!!!
    - @@ 생성자 함수 이름은 클래스 이름과 같다!!!
        ```
            Member( String name, String tel, String address)
                {this.name = name;
                this.tel = tel;
                this.address = address;}
        ```

3. 
    - 우리가 새로 생성자를 만들면,
    - 기존에 기본적으로 제공하던 Member()의 생성자는 사라진다.
    - 따라서 이 생성자도 써줘야한다!!!  --- << 메소드 오버로딩 >>
        ```
            Member(){}
        ```

#### 파라미터의 일부만 받아 집어넣기
- 주소는 나중에 받고, 이름이랑 전화번호만 먼저 받고 싶으면 어떻게 해야할까?
- 먼저 원하는 파라미터만 넣은 함수를 만들어본다
- 예시) Member m4 = new Member("영희", "010-4444-4444");
- 빨간줄이 뜨는데 이때 커서를 이 위로 가져가서 고치는 방법에는 어떤것이 있는지 확인해본다.
- 가장 밑의 create constructor 를 클릭하기
- 그러면 알아서 함수를 Member class(함수를 만들어둔 보조 클래스) 에 만들어준다.
    ```
        public Member(String string, String string2) {
            // TODO Auto-generated constructor stub
        }
    ```
- 보조클래스로 이동해 만들어진 함수의 파라미터를 내가 만든 함수에 맞게 수정한다.
- 앞의 퍼블릭은 지워주고  파라미터는 원하는 파라미터 이름으로 바꾼다.
    ```
        Member(String name, String tel) {
            // TODO Auto-generated constructor stub
            this.name = name;
            this.tel = tel;
        }
    ```
- 이렇게 수정하고 저장한 뒤 원 클래스로 가보면 잘 작동하는 것을 확인할 수 있다.

## 상속
- 클래스마다 공통된 변수가 존재한다면?
- 부모 클래스와 자식 클래스가 있음
- 공통된 변수 : 부모클래스에 넣어둠
- 자식 클래스는 부모 클래스의 멤버변수와 메소드를 전부 가지고있다

### 클래스 상속하기
- 클래스 상속 : 부모 클래스의 멤버변수와 함수까지 다 이용할 수 있음
- 쓰는 방법 클래스에 extends를 써준다
    ```
    public class Child extends Parent
    ```
- 상속받은 클래스에는 상속한 클래스 내용이 숨어있는것.
    ```
    public class Child extends Parent { // Parent 클래스 상속해서 이미 있는 데이터 가져오기
        // Parent의 멤버변수와 함수까지 다 이용할 수 있음.
        
        
    //	public String name;  --> 이 내용이 숨어있는것.
    //	public int age;      --> 이 내용이 숨어있는것.
    //	public int money;    --> 이 내용이 숨어있는것.
        public String hobby;
    }
    ```
#### ( 참고 ) 코드의 실행 순서
- 부모쪽 메모리 확보하고 생성자 호출
- 자식쪽 메모리 확보하고 생성자 호출
    ```
    (부모쪽 메모리 확보)
    - name
    - age
    - money
    ( 부모쪽 생성자 호출)
    public Parent(){ System.out.println("부모 생성자 호출됨"); } 
    (자식쪽 메모리 확보)
    - hobby
    (자식쪽 생성자 호출)
    public Child() { System.out.println("자식 생성자 호출됨"); }
    ```

### 부모 클래스의 변수가 프라이빗으로 바뀐다면
- 부모쪽의 변수들 중 하나를 프라이빗으로 바꾼다면 
- 이걸 상속받아 사용하고있는 클래스에서 **상속을 받을 순 있으나 노출이 안됨.**
- 변수를 프라이빗으로 만들어줬다면, 이걸 수정 하거나 가져올 수 있게 함수를 만들어 줘야함.
- getter, setter 함수를 만들어야 함.
- 부모 클래스에서 변수 앞에 private 이라는 조건을 걸면 그 변수를 상속받아 쓰고있는 다른 클래스에서 변수 이름에 빨간 줄이 생기는데, 빨간줄이 그어졌을때 마우스 커서를 올려 create getter, setter를 선택하면 알아서 함수를 만들어준다.
- 또는 빈공간에 커서를 놓고 마우스 오른쪽 클릭 - source - create getter and setter를 선택해서 만들 수 있다.
- 이렇게 부모 클래스에 함수를 만들어준 뒤, 자식 클래스와 메인 함수 클래스에서 get or set 함수를 사용 해 주면 된다.


### Method Overriding (메소드 오버라이딩)
- 부모에게 상속받은 프린트 함수 그대로 쓰고싶다면
- 함수 이름이 부모함수의 프린트 함수 이름과 같음.
- 부모한테 물려받은 함수 이름을 그대로 사용하되,
- 나에게 맞는 코드를 수정해서 사용한다.
    ```
        // (방법 1.) - 직접 타이핑
        //public void print() {System.out.println(name);
                    //System.out.println(age);
                    //System.out.println(getMoney()); 
                    //System.out.println(hobby);}

        // (방법 2.) -->> 보통 이 방법을 많이 사용. 상속받았다는걸 알 수 있어서.
        // 툴에서 제공하는것을 사용
        // 빈공간 - 마우스 오른쪽 - 소스 - 오버라이드 선택

        @Override  //--> 상속받았다는 뜻
        public void print() {
            // TODO Auto-generated method stub
            super.print();   	 // -->> super : 부모클래스를 뜻함.
            System.out.println(hobby); } 
    ```
- 생성자 쉽게 만드는 방법
- 마우스 오른쪽 - 소스 - generate constructor using fields 




