# 4월 21일 정리 추가
# 마크다운 사용하기
## '#' 을 쓰면 그냥 입력한 내용보다 크기가 크고 굵게 표시됨 
- #을 붙일수록 크키가 하나씩 작아짐.

## 목록 기호
- : '-', "*", "+' 세 가지는 똑같이 취급됨. 글자 앞에 - 표시 붙여주는거
- 목록1
  - 목록 1-1
  + 목록 1-2
      * 목록 1-1-1
      * 목록 1-1-1

## 표 만들기
열1 | 열2 | 열3
--- | --- | ---
행1열1| 행1열2| 행1열3
행2열1| 행2열2| 행2열3
---| ---| ---

## 링크 
[표시하고싶은 내용](링크)

## 코드블록 추가하는 방법
- '```(물결표 쉬프트 누르지 않았을때 나오는 기호)' 표시 세번 한 다음에 python 이라고 쓰고 그 뒤에 코드 쓰기. 마지막에도 기호 세번 써서 마무리
- ex)
```python
# 무한반복문
while True:
  print("hi")
  break #-> 무한반복 코드 정지하고싶을때

```


## 튜플형
- 튜플은 element의 값을 수정 할 수 없다.
- 튜플은 소괄호() 로 표시함.
- mutable(변하는, 수정 가능한) : 리스트(list), 딕셔너리(dict)
- ***immutable(불변하는, 변하지 않는)*** : 튜플(tuple), 정수(int), 실수(float), 문자열(str)
- 고로 수정을 하면 안되는 데이터를 튜플형식으로 만들어 놓으면 좋다.
- 삭제, 변경, 수정 모두 안됨.
- 다음 형식 모두 가능. 리스트와 사용방식은 동일.
- 연산자 사용 가능
- 값을 수정하는게 아니고 새 데이터를 만들어내는 개념이기때문에 가능.
- 이런 방식은 가능한가? :
```
t7 = t3 * 3
t7 = t3 * 4 
```     
-> 가능함. 왜? 데이터를 바꾼게 아니라 데이터가 있는 자리를 알려주는 화살표 방향을 바꾼것. 마지막에 *4를 한게 출력됨.

- 인덱싱, 슬라이싱 가능
- cf>>
- 슬라이싱의 특징 : 원래 데이터가 가지고있던 성질을 그대로 가져옴.
- 문자열을 슬라이싱 -> 슬라이싱된 부분 : 문자열데이터
- 리스트를 슬라이싱 -> 슬라이싱된 부분 : 리스트형 데이터
- 튜플을 슬라이싱 -> 슬라이싱된 부분 : 튜플형 데이터 -->> 고로 슬라이싱 한 부분도 튜플이 되어 수정 불가.
- 이걸 오름차순으로 정리하고 싶어도 정렬 불가. 왜? 값이 바뀌니까
- for 문 사용 가능


### 코드 실습
1. 구구단 원하는 단수 입력받아 출력해보기
- if n < 2 or n > 10:       ->       2~9 사이의 값이 아닐때 True
- 또는 if 2 <= n <= 9 (파이썬에서는 가능한 문법)  or     n>=2 and n<=9(보통의경우)         # -> 2~9 사이의 값일때 True

2.  
- 반복문을 어디다가 사용할 것인가 생각해보기.
- 반복문을 어디다가 쓸 것인가 -> 무한반복문(while)? if? for? 
- 반복문을 while로 만들어보고 for로 만들어보기
- 코드블럭 지키지 않으면 다른 결과값이 출력 될 수도 있다.

3. 코드 만들기 연습문제
```
# 문제))
# [1, 2, 3, 4, 5]
# [10, 20, 30, 40, 50]
# [532, 5941, 54682, 58, 5]
# 3개의 리스트에서 같은 인덱스의 값끼리 더하여 출력하기

print("실습하기 2 - 나의 풀이1")
li1 = [1, 2, 3, 4, 5]
li2 = [10, 20, 30, 40, 50]
li3 = [532, 5941, 54682, 58, 5]
print(li1[0]+li2[0]+li3[0])
print(li1[1]+li2[1]+li3[1])
print(li1[2]+li2[2]+li3[2])
print(li1[3]+li2[3]+li3[3])
print(li1[4]+li2[4]+li3[4])
print("\n")
#   --->> 그런데 이렇게 하면 안됨. 원하는건 반복문을 사용하여 문제 해결!


print("실습하기 2 - 해설")
li_1 = [1, 2, 3, 4, 5]
li_2 = [10, 20, 30, 40, 50]
li_3 = [532, 5941, 54682, 58, 5]
for i in range(5):
    print(li_1[i]+ li_2[i]+li_3[i])
print("\n")

print("실습하기 3 - 해설")
li_1 = [1, 2, 3, 4, 5]
li_2 = [10, 20, 30, 40, 50]
li_3 = [532, 5941, 54682, 58, 5]
i = 0
while i < 5:
    print(li_1[i]+ li_2[i]+li_3[i])
    i += 1
print("\n")

# 이런식으로 반복문을 사용하여 간단하고 쉽게 표현하기 연습해보기.
```


## zip()
- zip()
- 길이가 같은 list를 묶어서  for문 등으로 사용 가능한 iterable을 반환한다.
```
li_1 = [1, 2, 3, 4, 5]
li_2 = [10, 20, 30, 40, 50]
li_3 = [532, 5941, 54682, 58, 5]
        # --->> zip(li_1, li_2, li_3)
```

- 고로 다음과 같은 식이 가능하다
```
for x,y,z in zip(li_1, li_2, li_3):
   print(x+y+z)                    # --->> 결과 : [[1,10,531],[2,20,5941]....]
```

### 코드 실습
1. 코드 만들기 연습
```
# 문제))
# 정수를 입력 받고 그 정수의 약수를 모두 출력하기.
# 약수 : 나누었을때 나머지가 0으로 떨어지게 하는 수 ex) 2는 4의 약수, 2는 6의 약수....

print("실습하기 3 - 나의 풀이")
# a = int(input("정수 입력:"))
# for i in range(a+1):
#     if a % i == 0:
#         print(i)
#     else :
#         pass
print("\n")            ----->>> 오류남. 

### 해설
print("실습하기 3 - 해설1: for")
n = int(input("정수:"))
for i in range(1, n+1):   # 1 ~ m
    if n % i == 0:
        print(i)
print("\n")

print("실습하기 3 - 해설2: while")
n = int(input("정수:"))
i = 1
while i <= n:
    if n % i == 0:
        print(i)
    i += 1
print("\n")
```

# 오늘의 주의할 점
- 변수 생성시 1과 i를 항상 혼동함. 주의해서 사용하자!
- 콤마와 따옴표의 혼동도 주의.
- 스펠링 하나라도 틀리면 코드 안돌아감. 안돌아가면 오타 있는지 확인.
- 코드는 위에서부터 하나씩 진행된다. 안된다면 천천히 생각해보자.

